<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - simple text from json</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
      }
      #c {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
  </head>

  <body>
    <canvas id="c"></canvas>
    <script type="module">
      import * as THREE from "./js/three.module.js"

      import { OrbitControls } from "./js/OrbitControls.js"

      let camera, scene, renderer
      let mesh
      const amount = 10
      const meshCount = Math.pow(amount, 3)
      const transform = new THREE.Object3D()
      let scalingUp = true
      const maximumScale = 1.2
      let currentScale = 1
      let baseScale = 1

      init()
      animate()

      function init() {
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.1,
          10000
        )

        camera.position.set(amount * 1.7, -amount / 2, amount * 1.7)
        camera.lookAt(0, -amount / 2, 0)

        scene = new THREE.Scene()
        scene.background = new THREE.Color(0xffffff)

        const color = 0x111111
        const geometry = new THREE.BoxBufferGeometry(0.2, 0.2, 0.2)
        const material = new THREE.MeshLambertMaterial({
          color,
        })

        mesh = new THREE.InstancedMesh(geometry, material, meshCount)
        mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage) // will be updated every frame

        scene.add(mesh)

        scene.add(new THREE.AmbientLight(0x111111))

        const canvas = document.querySelector("#c")
        renderer = new THREE.WebGLRenderer({ canvas })
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)

        window.addEventListener("resize", onWindowResize, false)
      } // end init

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()

        renderer.setSize(window.innerWidth, window.innerHeight)
      }

      function animate() {
        requestAnimationFrame(animate)

        var time = Date.now() * 0.001

        mesh.rotation.x = Math.sin(time / 4)
        mesh.rotation.y = Math.sin(time / 2)

        if (scalingUp) {
          currentScale += 0.01
          mesh.scale.set(
            currentScale * baseScale,
            currentScale * baseScale,
            currentScale * baseScale
          )
          if (currentScale >= maximumScale) {
            scalingUp = false
          }
        } else {
          currentScale -= 0.01
          mesh.scale.set(
            currentScale * baseScale,
            currentScale * baseScale,
            currentScale * baseScale
          )
          if (currentScale <= 1) {
            scalingUp = true
          }
        }

        let i = 0
        let offset = (amount - 1) / 2

        for (let x = 0; x < amount; x++) {
          for (let y = 0; y < amount; y++) {
            for (let z = 0; z < amount; z++) {
              transform.position.set(offset - x, offset - y, offset - z)

              transform.updateMatrix()
              mesh.setMatrixAt(i++, transform.matrix)
            }
          }
        }

        mesh.instanceMatrix.needsUpdate = true

        render()
      }

      function render() {
        renderer.render(scene, camera)
      }
    </script>
  </body>
</html>
