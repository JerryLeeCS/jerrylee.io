<!DOCTYPE html>
<html lang="en">
  <head>
    <title>jerrylee.io</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        font-family: "sans-serif", Courier, monospace;
      }
      #c {
        position: absolute;
        width: 100%;
        height: 100%;
        display: block;
      }

      #body-layout {
        position: absolute;
        width: 100%;
        height: 100%;
      }

      #main-layout {
        position: relative;
        width: 100%;
        height: 100%;
      }

      #center-container {
        position: absolute;
        top: 70%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgb(255 249 249 / 69%);
      }
    </style>
  </head>

  <body>
    <canvas id="c"></canvas>
    <div id="body-layout">
      <div id="main-layout">
        <div id="center-container">
          <h1>
            Hi, my name is Jerry.
          </h1>
          <h2>
            I am a software engineer based in Los Angeles,CA specializing in building exceptional web apps.
          </h2>
        </div>
      </div>
    </div>
    <script type="module">
      import * as THREE from "./js/three.module.js"

      import { OrbitControls } from "./js/OrbitControls.js"

      let camera, scene, renderer
      let mesh
      const amount = 7
      const meshCount = Math.pow(amount, 3)
      const object3D = new THREE.Object3D()
      let cubeDistanceMultipler = 12
      const positions = []
      let targetIndices = Array(meshCount).fill(1).map((v,i) => i).sort(() => Math.random() - 0.5)

      init()
      animate()

      function init() {
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.1,
          10000
        )

        camera.position.set(amount * 1.7, -amount / 2, amount * 1.7)
        camera.lookAt(0, -amount / 2, 0)

        scene = new THREE.Scene()
        scene.background = new THREE.Color(0xffffff)

        const color = 0x111111	
        const geometry = new THREE.SphereBufferGeometry(0.2, 0.2, 0.2)
        const material = new THREE.MeshMatcapMaterial({color})

        mesh = new THREE.InstancedMesh(geometry, material, meshCount)
        mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage) // will be updated every frame

        //Cube formation
        let i = 0
        let offset = (amount - 1) / 2
        for (let x = 0; x < amount; x++) {
          for (let y = 0; y < amount; y++) {
            for (let z = 0; z < amount; z++) {
              const position = [
              (offset - x) * cubeDistanceMultipler * Math.random(),
                (offset - y) * cubeDistanceMultipler * Math.random(),
                (offset - z) * cubeDistanceMultipler * Math.random() 
              ]
              object3D.position.set(
                ...position
              )

              object3D.updateMatrix()
              mesh.setMatrixAt(i++, object3D.matrix)

              positions.push(position)
            }
          }
        }


        scene.add(mesh)

        scene.add(new THREE.AmbientLight(0x111111))

        const canvas = document.querySelector("#c")
        renderer = new THREE.WebGLRenderer({ canvas })
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)

        window.addEventListener("resize", onWindowResize, false)
      } // end init

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()

        renderer.setSize(window.innerWidth, window.innerHeight)
      }

      function animate() {
        requestAnimationFrame(animate)

        var time = Date.now() * 0.001

        mesh.rotation.x = Math.sin(time / 4)
        mesh.rotation.y = Math.sin(time / 2)

        let tempMatrix = new THREE.Matrix4();

        for (let i = 0; i < meshCount; i++){
          let targetIndex = targetIndices[i];
          const targetPosition = positions[targetIndex];
          const currentPosition = positions[i];

          const positionDifferences = targetPosition.map((targetPosition, i) => targetPosition - currentPosition[i])

          const newPosition = positionDifferences.map((positionDifference, i) => {
            let factor = 0.05
            return currentPosition[i] + (positionDifference * factor)
          })
          
          object3D.position.set(
            ...newPosition
          )

          object3D.updateMatrix()
          mesh.setMatrixAt(i, object3D.matrix);
          positions[i] = newPosition
        }

        mesh.instanceMatrix.needsUpdate = true

        render()
      }

      function render() {
        renderer.render(scene, camera)
      }
    </script>
  </body>
</html>
